---
id: architecture
title: Архитектура
---

Важнейшим аспектов при создании кроссплатформенного приложения на Avalonia,
является создание архитектуры, которая обеспечивает максимально возможное количество общего кода между платформами.
Для создания хорошо структурированного приложения, советуем придерживаться фундаментальных принципов ООП:

1. **Инкапсуляция** – This involves ensuring that classes and architectural layers only expose
a minimal API that performs their necessary functions while concealing the internal implementation details.
In practical terms, this means that objects operate as 'black boxes', 
and the code utilizing them doesn't need to comprehend their internal workings. 
Architecturally, it implies implementing patterns like the Façade that promote
a simplified API orchestrating more complex interactions on behalf of the code in higher abstract layers. 
Hence, the UI code should focus solely on displaying screens and accepting user input, 
never directly interacting with databases or other lower-level operations.

Это предполагает обеспечение того, чтобы классы и архитектурные уровни предоставляли только
минимальный API, который выполняет их необходимые функции, скрывая при этом внутренние детали реализации.
На практике это означает, что объекты работают как "черные ящики",
и коду, использующему их, не нужно понимать их внутреннюю работу.
Архитектурно это подразумевает реализацию шаблонов, подобных Façade, которые способствуют
упрощению API, организующего более сложные взаимодействия от имени кода на более высоких абстрактных уровнях.
Следовательно, код пользовательского интерфейса должен быть сосредоточен исключительно на отображении экранов и принятии пользовательского ввода,
никогда напрямую не взаимодействуя с базами данных или другими операциями более низкого уровня.

2. **Разделение ответственности** – Каждый компонент архитектуры или класса, должен иметь четкое назначение,
выполнять только свои определенные задачи, а также предоставлять доступ к этой функциональности
для других классов через API.
3. **Полиморфизм** – Использование интерфейсов (или абстрактных классов),
позволяет писать общий код для приложений
Programming to an interface (or an abstract class) 
supporting multiple implementations allows core code to be written 
and shared across platforms while still interacting with platform-specific
features offered by Avalonia.

Программирование с использованием интерфейса (или абстрактного класса)
поддержка нескольких реализаций позволяет писать базовый код
и совместно использовать его на разных платформах, в то же время взаимодействуя со специфичными для платформы
функциями, предлагаемыми Avalonia.

Результатом применения этих принципов, является приложение, основанное на реальных или абстрактных сущностях с различными логическими слоями.

Разделенине кода на слои, упрощает понимание, тестирование и поддержку приложения.
Рекомендуется как хранить код для каждого из уровней раздельно (разные каталоги или отдельные проекты), так и логически, испоьлзуя пространства имен.
Avalonia позволяет совместно использовать не только бизнес-логику, но и код UI для разных платформ, что уменьшает необходимость
в нескольких проектах пользовательского интерфейса и еще больше расширяет возможности переиспользования кода.

## Типичные слои приложения

В данном документе и тематических исследованиях, мы ссылаемся на следующие шесть слоев приложения:

1. **Слой данных** – здесь происходит сохранение данных, вероятно, с помощью базы данных, таких как `SQLite` или `LiteDB`,
но может быть реализовоно и с помощью других механизмов, к примеру XML-файлов.
2. **Слой доступа к данным** – This layer is a wrapper around the Data Layer providing Create, Read, Update, Delete (CRUD) operations
on the data without revealing implementation details to the caller. 
For instance, the DAL might contain SQL queries to interact with the data, but the code referencing it doesn't need to be aware of this.

Этот уровень является оболочкой вокруг уровня данных, обеспечивающей операции создания, чтения, обновления, удаления (CRUD)
данных без раскрытия деталей реализации вызывающей стороне.
Например, DAL может содержать SQL-запросы для взаимодействия с данными, но коду, ссылающемуся на него, не обязательно знать об этом.

3. **Слой бизнес-логики** – Sometimes referred to as the Business Logic Layer or BLL, 
this layer houses business entity definitions (the Model) and business logic. 
It is a prime candidate for the Business Facade pattern.

Иногда называемый уровнем бизнес-логики или BLL,
этот уровень содержит определения бизнес-сущностей (модель) и бизнес-логику.
Это основной кандидат для шаблона бизнес-фасада.

4. **Слой доступа к сервисам** – This layer is used to access services in the cloud, 
ranging from complex web services (REST, JSON) to simple retrieval of data and images from remote servers. 
It encapsulates networking behaviour and provides a streamlined API for consumption by the Application and UI layers.

Этот уровень используется для доступа к облачным сервисам,
начиная от сложных веб-сервисов (REST, JSON) и заканчивая простым извлечением данных и изображений с удаленных серверов.
Он инкапсулирует сетевое поведение и предоставляет оптимизированный API для использования на уровнях приложений и пользовательского интерфейса.

5. **Слой приложения** – This layer contains code that is generally platform-specific or code that is specific to the application (not typically reusable).
In the Avalonia framework, this layer is where you decide which platform-specific features to leverage if any.
The distinction between this layer and the UI layer becomes clearer with Avalonia since the UI code can be shared across platforms.

Этот уровень содержит код, который обычно зависит от платформы, или код, специфичный для приложения (обычно не используемый повторно).
В Avalonia framework на этом уровне вы решаете, какие функции, зависящие от платформы, использовать, если таковые имеются.
Различие между этим уровнем и уровнем пользовательского интерфейса становится более четким с Avalonia, 
поскольку код пользовательского интерфейса может быть общим для разных платформ.

6. **Слой пользовательского интерфейса (UI)** – This user-facing layer contains views and the view-models that manage them. 
Avalonia makes it possible for this layer shared across every supported platform, 
unlike traditional architectures where the UI layer would be platform-specific.

Этот пользовательский уровень содержит представления и модели представлений, которые ими управляют.
Avalonia делает возможным совместное использование этого уровня на каждой поддерживаемой платформе,
в отличие от традиционных архитектур, где уровень пользовательского интерфейса зависит от платформы.

Приложение может не содержать некоторые из слоев. Например, уровень доступа к сервисам может не присутствовать в приложении,
которое не работает с сетевыми ресурсами.
В более простых приложениях, можно объединить слой данных со слоем доступа данных, поскольку эти операции довольно просты.
Avalonia поддерживает вохможность гибкого формирования архитектуры приложения, в соответствии с вашими потребностями,
что обеспечивает высокую степень переиспользования кода на разных платформах.

## Общие архитектурные паттерны

Паттерны - это хорошо зарекомендовавший себя подход, для стандартизации решения распостраненных проблем.
Есть несколько ключевых паттернов, которые стоит использовать при создании приложений на Avalonia.

### Model, View, ViewModel (MVVM) 
MVVM - это популярный, но в то же время часто неправильно используемый шаблон.
В основном, он используется при построении пользовательских интерфейсов и способствует разделению между фактическим определением экрана UI (View),
стоящей за ней логику (`ViewModel`) и заполняющих его данных (`Model`).
В нем, `ViewModel` выступает посредником между `View` и `Model`.
И пусть `Model` важна, но она является независимой, опциональной частью.
Поэтому суть паттерна сводится ко взаимосвязи между `View` и `ViewModel`.

:::info
Подробнее о паттерне MVVM, см. [здесь](../../concepts/the-mvvm-pattern/).
:::

### Business Façade (рус: Фасад)
Данный паттерн обепечивает упрощенную точку входа для сложных операций.
Например, в приложении отслеживаются задачи через класс TaskManager с методами GetAllTasks(), GetTask(TaskId),
SaveTask(task) и т.д.
Данный класс обеспечивает `Faсade` лоя внутренних механизмов оюбъектов `tasks`.

### Singleton (рус: Одиночка)
Паттерн `Singleton` гарантирует, что может существовать только один единственный экземпляр указанного объекта.
Например, при использовании в приложениях `SQLite`, обычно требуется только один экземпляр базы данных.

### Provider (рус: Поставщик)
Паттерн впервые придумал Microsoft для решения проблемы повторного использования кода между приложениями на `Silverlight`, `WPF` и `WinForms`.
Общий код описывается с помощью интерфейсов или абстрактных классов, а уже конкретные реализации пишутся под конкретную платформу,
и потом передаются при использовании кода.
Поскольку в Avalonia мы можем и UI, и логику в общем коде приложений, то данный паттерн может помочь в обработке исключений
на разных платформах, а также использовать платформозависимые функции.

### Async (рус: Асинхронность)
Не следует путать шаблон `Async` с одноименным ключевым словом.
Шаблон используется, когда необходимо выполнять длительные задачи без зависания UI или текущей обработки.
В простой форме, паттерн `Async` указывает, что длительные задачи должны запускаться в другом потоке (или аналогичной абстракции, к примеру `Task`),
в то время как текущий поток продолжает обработку и ожидает ответа от фонового процесса.
Обновление UI происходит при возврате данных или состояния.
Это важно для поддержания отзывчивого UI в приложениях Avalonia.

---
Каждый из упомянутых выше паттернов, будет подробно изучен в рамках демонстрации наших тематических исследований.
Для подробного понимания паттерном, рекомендуем ознакомиться со статьями [Facade (рус: Фасад)](https://en.wikipedia.org/wiki/Facade_pattern), 
[Singleton (рус: Одиночка)](https://en.wikipedia.org/wiki/Singleton_pattern) и [Provider (рус: Поставщик)](https://en.wikipedia.org/wiki/Provider_model), 
а также с [Design Patterns (рус: Паттернами проектирования)](https://en.wikipedia.org/wiki/Design_Patterns) в целом.